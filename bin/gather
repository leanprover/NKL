#!/usr/bin/env python3

# This is a simple script which will load and parse a kernel function
# This code does not try to apply prototype arguments to the function,
# rather, it leaves the argument list empty. This will cause the Lean
# side to try to infer prototype arguments for the function.

# This is just a POC to try out different ways of organizing the tooling.
# The intention is to create a more typical compiler interface: e.g.
#   klr gather mylib.kernels.mykernel -o mykernel.json
#   klr trace mykernel.json -o mykernel.klr
#   klr compile mykernel.klr -o mykernel.bir
# This script is the "gather" step, e.g.
#  PYTHONPATH=interop:interop/test ./bin/gather examples.layout.tensor_exp_kernel_2

import sys
import importlib
import klr

if len(sys.argv) != 2:
  print(f"Usage: {sys.argv[0]} function", file=sys.stderr)
  sys.exit(1)

[bin, kernel] = sys.argv

pieces = kernel.split(".")
if len(pieces) < 2:
  print("Please, specify full path name of function, e.g.:", file=sys.stderr)
  print(f"  {bin} mylib.mykernel", file=sys.stderr)
  sys.exit(1)

try:
  fn = pieces.pop()
  module = ".".join(pieces)
  m = importlib.import_module(module)
  f = getattr(m, fn)
  F = klr.parser.Parser(f)
  print(F.json())
except Exception as e:
  print(str(e), file=sys.stderr)
  sys.exit(1)
